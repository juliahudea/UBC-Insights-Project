{"version":3,"file":"/Users/julia/Documents/UBC/BCS/CPSC 310/project_team062/src/controller/LoadHelperFunctions.ts","sources":["/Users/julia/Documents/UBC/BCS/CPSC 310/project_team062/src/controller/LoadHelperFunctions.ts"],"names":[],"mappings":"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","sourcesContent":["import {IInsightFacade, InsightDataset, InsightDatasetKind, InsightError, InsightResult} from \"./IInsightFacade\";\nimport Section, {getValidSections} from \"./Section\";\nimport * as fs from \"fs-extra\";\nimport * as path from \"path\";\nimport JSZip from \"jszip\";\n\nasync function loadDatasets(): Promise<{[id: string]: InsightDataset}> {\n\n\t// console.log(\"Loading datasets\");\n\ttry {\n\t\tif (!await fs.pathExists(path.join(__dirname, \"../../data/data.json\"))) {\n\t\t\treturn Promise.reject(new InsightError(\"No datasets to load\"));\n\t\t}\n\t} catch (e) {\n\t\treturn Promise.reject(e);\n\t}\n\n\tlet loadedDatasets: any = await fs.readFile(path.join(__dirname, \"../../data/data.json\"), \"utf8\").catch((err) => {\n\t\treturn Promise.reject(new InsightError(\"Failed to read dataset from file\"));\n\t});\n\t// console.log(JSON.parse(loadedDatasets));\n\treturn Promise.resolve(JSON.parse(loadedDatasets));\n}\n\nasync function unzipFile(content: string): Promise<JSZip> {\n\tconst jszip = new JSZip();\n\tlet unzippedFile = await jszip.loadAsync(content, {base64: true}).catch((error) => {\n\t\treturn Promise.reject(new InsightError(\"Not a zip file\"));\n\t});\n\n\tif (!checkDirName(unzippedFile)) {\n\t\treturn Promise.reject(new InsightError(\"Incorrect Directory structure\"));\n\t}\n\n\treturn Promise.resolve(unzippedFile);\n}\n\nfunction checkDirName(file: JSZip): boolean {\n\tlet counter = 0;\n\tfile.forEach((filePath, filter): void => {\n\t\tif(filePath.split(\"/\",1)[0] === \"courses\" && counter > -1) {\n\t\t\tcounter++;\n\t\t} else {\n\t\t\tcounter = -1;\n\t\t}\n\t});\n\treturn (counter > 0);\n}\n\nasync function parseFile(jszip: JSZip): Promise<Section[]> {\n\tlet sections: Section[] = [];\n\tconst courses = jszip.file(/courses/);\n\t// console.log(courses);\n\n\t// check that the folder exists\n\tif (courses.length === 0) {\n\t\t// console.log(\"No course folder\");\n\t\treturn Promise.reject(new InsightError(\"No course folder\"));\n\t}\n\tlet validJson = false;\n\n\tconst promises = courses.map(async (course) => {\n\t\tconst fileContent = await course.async(\"string\");\n\t\ttry {\n\t\t\t// parse file content, if its not a valid json, catch error and continue to next file\n\t\t\tconst jsonData = await JSON.parse(fileContent);\n\n\t\t\t// indicate that a valid json was found\n\t\t\tvalidJson = true;\n\n\t\t\t// get valid sections from the json data\n\t\t\treturn getValidSections(jsonData);\n\t\t} catch (e) {\n\t\t\t// Return an empty array if there was an error parsing the file\n\t\t\treturn [];\n\t\t}\n\t});\n\n\tsections.push(...(await Promise.all(promises)).flat());\n\t\t/*\n\t\tfor (const filePath of fileNames) {\n\t\t\tif (courses && !courses.files[filePath].dir) { // Check that it's a file, not a directory\n\t\t\t\tconst fileContent = await courses.files[filePath].async(\"string\");\n\t\t\t\ttry {\n\t\t\t\t\t// parse file content, if its not a valid json, catch error and continue to next file\n\t\t\t\t\tconst jsonData = await JSON.parse(fileContent);\n\n\t\t\t\t\t// indicate that a valid json was found\n\t\t\t\t\tvalidJson = true;\n\n\t\t\t\t\t// get valid sections from the json data\n\t\t\t\t\tsections.push.apply(sections, await getValidSections(jsonData)); // Push each section individually\n\t\t\t\t} catch (e) {\n\t\t\t\t\tcontinue; // Exit the current iteration and continue to the next file\n\t\t\t\t}\n\t\t\t}\n\t\t\t*/\n\n\tif (!validJson) {\n\t\treturn Promise.reject(new InsightError(\"No valid JSON\"));\n\t}\n\n\tif (sections.length === 0) {\n\t\treturn Promise.reject(new InsightError(\"No valid sections\"));\n\t}\n\n\treturn Promise.resolve(sections);\n}\n\nasync function writeToDisk(datasets: {[id: string]: InsightDataset}): Promise<void> {\n\tlet result;\n\tlet dataResult = [];\n\ttry {\n\t\tconst storageDir = path.join(__dirname, \"../../data\");\n\t\tconst storagePath = path.join(__dirname, \"../../data/data.json\");\n\t\tconst dataToWrite = JSON.stringify(datasets);\n\t\ttry {\n\t\t\tresult = await fs.pathExists(storageDir);\n\t\t\tif (!result) {\n\t\t\t\tresult = await fs.mkdir(storageDir);\n\t\t\t}\n\t\t} catch (e) {\n\t\t\treturn Promise.reject(e);\n\t\t}\n\t\tresult = await fs.writeFile(storagePath, dataToWrite, \"utf8\");\n\t} catch (error) {\n\t\treturn Promise.reject(new InsightError(\"Failed to write dataset to file\"));\n\t}\n}\n\nasync function addSectionData(id: string, data: Section[]): Promise<boolean> {\n\treturn Promise.resolve(true);\n}\n\nasync function getSectionData(id: string): Promise<boolean> {\n\treturn Promise.resolve(true);\n}\n\nasync function removeSectionData(id: string): Promise<boolean> {\n\treturn Promise.resolve(true\n\t);\n}\n\nfunction stringToHashString(name: string): string {\n\tlet hash = \"\";\n\tif (!name.length) {\n\t\treturn hash;\n\t}\n\tfor (const char of name) {\n\t\thash = hash.concat(char.charCodeAt(0).toString(16));\n\t}\n\treturn hash;\n}\n\nexport {loadDatasets, unzipFile, parseFile, writeToDisk, addSectionData, getSectionData, removeSectionData};\n\n"]}